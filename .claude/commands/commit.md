---
description: Commit only the changes YOU made in this session
---

Commit code changes that YOU (this Claude session) made. Execute without asking for confirmation.

## Modes

**Default:** Commit changes you made this session as a single atomic commit.

**With `--all` flag:** Find ALL uncommitted changes and group them intelligently into multiple commits. Use this when returning to a project with accumulated changes from multiple work sessions.

## Why This Matters

Commits are communication. Someone reading `git log` six months from now should understand what happened and why. Someone bisecting a bug should find atomic changes that either contain the bug or don't—not tangled commits where the bug could be anywhere.

Clean commits also protect the user's professional reputation. AI-generated commit messages with "Co-authored-by" tags or boilerplate language mark their history as automated. The user's commits should look like a professional wrote them.

## What Makes a Good Commit

**Atomic:** One logical change. If you implemented a feature and fixed a bug, that's two commits. If you can't describe it in one sentence, it's probably not atomic.

**Attributable:** Only commit what YOU changed this session (unless using `--all`). If you see modifications you don't recognize, leave them alone—they're someone else's work in progress.

**Clear:** The message explains what and why in imperative mood. "Add token refresh" not "Added token refresh" or "This adds token refresh."

Use conventional format (`type(scope): description`) because it enables automated changelogs and semantic versioning. Types: `feat`, `fix`, `refactor`, `style`, `docs`, `test`, `chore`. Keep it under 72 characters.

No AI fingerprints. No "Co-authored-by", no "Generated by", no emoji unless the project uses them.

## Grouping Changes (--all mode)

When multiple unrelated changes exist, group them into separate commits by purpose:

- Changes serving the same feature belong together
- Changes fixing the same bug belong together
- A refactor touching many files but serving one goal is one commit
- Proximity in directory tree isn't relationship—different purposes means different commits

Ask: "If someone had to revert this, what would make sense to undo as a unit?"

## Safety Awareness

Some files should never be committed regardless of context: secrets (`.env`, `*.pem`, `*.key`), build artifacts that should be gitignored (`node_modules/`, `dist/`, `.next/`).

If you encounter these, skip them silently and mention in the summary. Don't ask, don't commit, don't stop—just note what was skipped and why.

## Capturing Discoveries

While working, you likely noticed things: tech debt, potential bugs, improvement opportunities. This is the moment to capture them—your context is fresh.

Read `.claude/state.json`. Add genuine discoveries to the backlog—things that would be valuable to address later. Each item needs enough context that a future session (maybe not you) can understand and act on it: what you found, where, why it matters.

Don't pad the backlog with noise. If you discovered nothing worth tracking, that's fine.

## After Committing

Report what was committed (and how it was grouped, if using `--all`). If you added backlog items, commit that state change separately.

Don't push—that's `/push` when the user is ready.

$ARGUMENTS
